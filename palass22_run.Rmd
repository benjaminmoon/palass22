---
---



```{r chunk_tag, echo = FALSE}
renv::restore()
```

```{r libraries}
library(tidyverse)

library(future)
library(furrr)

library(coda)
library(deeptime)                      # https://github.com/willgearty/deeptime

library(viridis)

dirs <-
  list(
    data   = "./data/",
    figs   = "./figs/",
    geog   = "./data/palaeogeog_outlines/",
    output = "./output/",
    pyrate = "./output/pyrate/"
  )
for (directory in dirs) {
  if (!dir.exists(directory)) dir.create(directory)
}

source("./functions/functions.R")
source("https://raw.githubusercontent.com/dsilvestro/PyRate/master/pyrate_utilities.r")
```

```{r load_data}
data <-
  read_tsv(paste0(dirs$data, "ichthyosaur_occurrences.tsv")) |>
  filter(
    accepted_rank == "species",
  ) |>
  mutate(accepted_name =
    str_remove(accepted_name, "aff\\. |cf\\. |sp\\.|\\?")) |>
  separate_rows(specimen_no, sep = ", ") |>
  select(accepted_name, max_ma, min_ma) |>
  write_tsv(paste0(dirs$pyrate, "ichthyosaur_species_occurrences.tsv"))

data |>
  pull(accepted_name) |>
  unique() |> sort()

range_data <-
  data |>
  mutate(range = max_ma - min_ma)

range_data |>
  filter(range > 10) |>
  arrange(desc(range))

range_data |>
  ggplot(aes(x = reorder(accepted_name, range), y = range, colour = reorder(accepted_name, range))) +
    geom_point(show.legend = FALSE) +
    coord_flip() +
    scale_colour_viridis(discrete = TRUE) +
    labs(x = "Taxon", y = "Dating precision (Ma)") +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
ggsave(file = paste0(dirs$figs, "taxon_dating_precision.pdf"), width = 5, height = 3)

range_data |>
  ggplot(aes(x = reorder(accepted_name, desc(max_ma)), ymin = min_ma, ymax = max_ma, colour = reorder(accepted_name, desc(max_ma)))) +
    geom_linerange(position = position_dodge2(width = 1), lwd = 2, show.legend = FALSE) +
    coord_flip() +
    scale_y_reverse() +
    scale_colour_viridis(discrete = TRUE) +
    labs(x = "Taxon", y = "Dating range (Ma)") +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
ggsave(file = paste0(dirs$figs, "taxon_precision_time.pdf"), width = 5, height = 3)

range_data |>
  ggplot(aes(
      x = range,
      ymin = min_ma,
      ymax = max_ma,
      colour = reorder(accepted_name, max_ma))) +
    geom_linerange(show.legend = FALSE, lwd = 2) +
    coord_flip(xlim = c(0, 27.2)) +
    scale_y_reverse() +
    scale_colour_viridis(discrete = TRUE) +
    labs(x = "Dating precision (Ma)", y = "Occurrence ranges (Ma)")
ggsave(file = paste0(dirs$figs, "taxon_range_precision_time.pdf"), width = 5, height = 3)

range_data |>
  group_by(accepted_name) |>
  summarize(count = n()) |>
  ggplot(aes(x = reorder(accepted_name, count), y = count, fill = reorder(accepted_name, count))) +
    geom_col(show.legend = FALSE) +
    coord_flip() +
    scale_fill_viridis(discrete = TRUE) +
    labs(x = "Taxon", y = "Specimen count") +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
ggsave(file = paste0(dirs$figs, "taxon_specimen_counts.pdf"), width = 5, height = 3)

full_data <-
  read_tsv(paste0(dirs$data, "ichthyosaur_occurrences.tsv")) |>
  mutate(accepted_name =
    str_remove(accepted_name, "aff\\. |cf\\. |sp\\.|\\?")) |>
  separate_rows(specimen_no, sep = ", ") |>
  select(accepted_name, accepted_rank, max_ma, min_ma) |>
  mutate(range = max_ma - min_ma)

specimens_through_time <-
  250:90 |>
  map_dfr(function(.x) {
    full_bin_count <-
      full_data |>
      filter(max_ma > .x - 1, min_ma < .x) |>
      nrow()
    bin_count <-
      full_data |>
      filter(accepted_rank == "species", max_ma > .x - 1, min_ma < .x) |>
      nrow()
    list(bin_start = .x, count_named = bin_count, count_unnamed = full_bin_count - bin_count)
  })

specimens_through_time |>
  pivot_longer(matches("count"), names_to = "dataset", names_prefix = "count_", values_to = "count") |>
  ggplot(aes(x = bin_start - 0.5, y = count, fill = reorder(dataset, desc(dataset)))) +
    geom_col(show.legend = FALSE) +
    scale_x_reverse() +
    scale_fill_viridis(discrete = TRUE, end = 0.6, name = "Identity") +
    # coord_geo(xlim = c(250, 90), dat = "stages", center_end_labels = TRUE, dat_is_discrete = TRUE, lab = FALSE, color = NA, height = unit(0.2, "line")) +
    labs(x = "Age (Ma)", y = "Number of specimens")
ggsave(file = paste0(dirs$figs, "specimen_counts_time.pdf"), width = 5, height = 3)

extract.ages.pbdb(
  file = paste0(dirs$pyrate, "ichthyosaur_species_occurrences.tsv"),
  sep = "\t",
  replicates = 24, # how many cores on a node
  cutoff = 10,
)
```

```{r pyrate_create_submission_scripts, eval = FALSE}
submission_script_base <-
  paste(
    "#!/bin/bash",
    "### PBDB  occurrences",
    "### 10 replicates array job",
    "### name of job",
    "#PBS -N Pg_$1",
    "### time to stop job",
    "#PBS -l walltime=72:00:00",
    "### number of nodes/cpus *for each job*",
    "### in this case each run of PyRate uses 1 CPU",
    "#PBS -l select=1:ncpus=1:mem=4gb",
    "### index range for subjobs",
    "### this is how many runs of PyRate we want",
    "#PBS -J 1-10",
    "### add Python 3.8 module",
    "module add lang/python/anaconda/3.8.3-2020-math",
    paste(
      "python3 /work/glbcm/PyRate/PyRate.py -n 100000000 -s 5000 -se_gibbs",
      "-qShift /work/glbcm/pg_pyrate/ages.txt -fU 0.2 0.78 0.0",
      "-j $PBS_ARRAY_INDEX -edgeShift 66 23 -out $1",
      "/work/glbcm/pg_pyrate/Pg_$1_PyRate.py",
      sep = " "
    ),
    sep = "\n"
  )

sub_filename <-
  paste0(dirs$pyrate, "pyrate_submission.sh")
cat("#!/bin/bash\n", file = sub_filename)
for (taxon in taxon_matching) {
  modified_script <-
    gsub("\\$1", taxon$taxon_name, submission_script_base)
  filename <-
    paste0(taxon$taxon_name, "_sub.sh")
  cat(modified_script, file = paste0(dirs$pyrate, filename))
  runscript_line <-
    paste("qsub", filename, "\n", sep = " ")
  cat(
    runscript_line,
    file = sub_filename,
    append = TRUE
  )
}

# ages.txt needed for -se-gibbs sampling
system2(
  "cp",
  args = paste(
    paste0(dirs$data, "ages.txt"),
    paste0(dirs$pyrate, "ages.txt")
  )
)
```

```{r combine_pyrate}
ess_statistics <-
  list.files(path = paste0(dirs$pyrate, "/pyrate_mcmc_logs/"), pattern = "rj_mcmc", full.names = TRUE) |>
  map(~ read.table(.x, header = TRUE, row.names = 1)) |>
  bind_cols() |>
  rownames_to_column()
```

```{r process_pyrate_results}
process_pyrate_results()

plot_labels <-
  c(
    sp_rates  = "Speciation rate",
    sp_shifts = "Speciation rate shifts",
    ex_rates  = "Extinction rate",
    ex_shifts = "Extinction rate shifts",
    net_rates = "Net diversification rate",
    longevity = "Species longevity"
  )
# Use the colour scheme No. 5 from
# https://digitalsynopsis.com/design/minimal-web-color-palettes-combination-hex-code/
# with an added blue
plot_colours <- c(rep("#2F9599", 2), rep("#EC2049", 2), "#4378CB", "#A7226E")
names(plot_colours) <- plot_labels

pyrate_bayesfactors <- read_pyrate_bayesfactors()
pyrate_results <- read_pyrate_results()

# dev.new(width = 10.47, height = 6.54)
# pyrate_plot <-
  pyrate_results |>
    ggplot(
      aes(
        x      = time,
        y      = rate,
        ymin   = minHPD,
        ymax   = maxHPD,
        xend   = time,
        yend   = 0,
        # yintercept = value,
        colour = plt_curve,
        fill   = plt_curve,
        # group  = taxon
      )
    ) +
      pyrate_facet_taxon_curve() +
      # pyrate_plot_eotlabel() +
      pyrate_plot_curves() +
      # pyrate_plot_shifts() +
      pyrate_plot_axes() +
      pyrate_plot_theme()

pyrate_plot
pyrate_plot_save(pyrate_plot)
```

```{r occurrence_histograms}
log_data <-
  read_tsv("./output/pyrate/pyrate_mcmc_logs/combined_10mcmc.log", n_max = 10000) |>
  pivot_longer(
    cols = ends_with(c("TS", "TE")),
    names_to = "parameters",
    values_to = "value"
  )

log_data |>
  ggplot(aes(value, after_stat(density))) +
  geom_histogram(binwidth = 0.1) +
  # facet_wrap(vars(parameters), ncol = 1, strip.position = "right") +
  scale_x_reverse() +
  coord_geo(dat = "stages") +
  theme(legend.position = "none")
```

```{r alternative_pyrate}
pyrate_logs <-
  read_tsv(paste0(dirs$pyrate, "pyrate_mcmc_logs/combined_10TPP-subages_mcmc.log"))
```


```{r building_trees}
library(ape)
library(pbapply)
library(phangorn)
library(tidyverse)
library(furrr)

bindellini_trees <-
  read.tree("./data/phylogeny/Bindellini2021PJ-trees.tre") |>
  root("Petrolacosaurus", resolve.root = TRUE)
moon_trees <-
  read.tree("./data/phylogeny/Moon2019CB-trees.tre") |>
  root("Hupehsuchus_nanchangensis", resolve.root = TRUE)
sander_tree <-
  read.nexus("./data/phylogeny/Sander2021S-tree.nex") |>
  root("Hupehsuchus_nanchangensis", resolve.root = TRUE)
chen_tree <-
  read.tree("./data/phylogeny/Chen2014PO-tree.tre") |>
  root("Seymouriidae", resolve.root = TRUE)

# standardize the taxonomy
list(
  bindellini_not_in_moon = bindellini_trees[[1]]$tip.label[
  !bindellini_trees[[1]]$tip.label %in% moon_trees[[1]]$tip.label
],
  moon_not_in_bindellini = moon_trees[[1]]$tip.label[
  !moon_trees[[1]]$tip.label %in% bindellini_trees[[1]]$tip.label
],
  bindellini_not_in_sander = bindellini_trees[[1]]$tip.label[
  !bindellini_trees[[1]]$tip.label %in% sander_tree$tip.label
],
  sander_not_in_moon = sander_tree$tip.label[
  !sander_tree$tip.label %in% moon_trees[[1]]$tip.label
],
  chen_not_in_sander = chen_tree$tip.label[
  !chen_tree$tip.label %in% sander_tree$tip.label
],
  chen_not_in_bindellini = chen_tree$tip.label[
  !chen_tree$tip.label %in% bindellini_trees[[1]]$tip.label
]
)

taxon_match <-
  c(
    "Besanosaurus"               = "Besanosaurus_leptorhynchus",
    "Californosaurus"            = "Californosaurus_perrini",
    "Callawayia_wolonggangense"  = "Guizhouichthyosaurus_wolonggangense",
    "Callawayia_wolonggangensis" = "Guizhouichthyosaurus_wolonggangense",
    "Cartorhynchus"              = "Cartorhynchus_lenticarpus",
    "Chaohusaurus"               = "Chaohusaurus_geishanensis",
    "Cymbospondylus_piscosus"    = "Cymbospondylus_petrinus",
    "Eohupehsuchus"              = "Eohupehsuchus_brevicollis",
    "Eretmorhipis"               = "Eretmorhipis_carrolldongi",
    "Grippia"                    = "Grippia_longirostris",
    "Guanlingsaurus"             = "Shastasaurus_liangae",
    "Guizhouichthyosaurus"       = "Guizhouichthyosaurus_tangae",
    "Gulosaurus"                 = "Gulosaurus_helmi",
    "Hudsonelpidia"              = "Hudsonelpidia_brevirostris",
    "Hupehsuchus"                = "Hupehsuchus_nanchangensis",
    "Macgowania"                 = "Macgowania_janiceps",
    "Mixosaurus_panxianensis"    = "Barracudasauroides_panxianensis",
    "Nanchangosaurus"            = "Nanchangosaurus_suni",
    "Parahupehsuchus"            = "Parahupehsuchus_longus",
    "Parvinatator"               = "Parvinatator_wapitiensis",
    "Phalarodon_atavus"          = "Contectopalatus_atavus",
    "Sclerocormus"               = "Sclerocormus_parviceps",
    "Shastasaurus"               = "Shastasaurus_pacificus",
    "Shastasaurus_sikkaniensis"  = "Shastasaurus_sikanniensis",
    "Shonisaurus_sikkaniensis"   = "Shastasaurus_sikanniensis",
    "Thalattoarchon"             = "Thalattoarchon_saurophagis",
    "Utatsusaurus"               = "Utatsusaurus_hataii",
    "Xinminosaurus"              = "Xinminosaurus_catactes"
  )

availableCores()
plan(multisession)

standardize_tree_names <-
  function(phy, taxon_names) {
    # Standardize taxon names in a tree(s) based on a given 'dictionary'.
    #
    # Args:
    #   phy: a `phylo` or `multiPhylo` object.
    #   taxon_names: a named character vector. The values of the vector are the correct names and each should be named with the value to be changed.
    #
    # Returns:
    #   A `phylo` or `multiPhylo` object with the tip labels modified.
    #
    # Notes:
    #   For `multiPhylo` objects this is can be parallelized as it's implemented using the *furrr* package. Plan a multisession or multithread beforehand to automatically use this.
    require(stringr)
    require(furrr)
    # add look arounds to the taxon names to prevent matching partial strings
    names(taxon_names) <- paste0("(?<!.)", names(taxon_names), "(?!.)")
    if (class(phy) == "phylo") {
      phy$tip.label <- stringr::str_replace_all(phy$tip.label, taxon_names)
    } else if (class(phy) == "multiPhylo") {
      phy <-
        furrr::future_map(
          phy, function(.x) {
            .x$tip.label  <- stringr::str_replace_all(.x$tip.label, taxon_names)
            .x
          }, .progress = TRUE
        )
      class(phy) <- "multiPhylo"
    } else {
      stop("phy is not a 'phylo' or 'multiPhylo' object.")
    }
    phy
  }

bindellini_trees <-
  standardize_tree_names(bindellini_trees, taxon_match)
moon_trees <-
  standardize_tree_names(moon_trees, taxon_match)
chen_tree <-
  standardize_tree_names(chen_tree, taxon_match)



Hupehsuchia <-
  c("Eohupehsuchus_brevicollis", "Eretmorhipis_carrolldongi", "Hupehsuchus_nanchangensis", "Nanchangosaurus_suni", "Parahupehsuchus_longus")
outgroups <-
  c("Claudiosaurus", "Hovasaurus", "Petrolacosaurus", "Thadeosaurus", "Wumengosaurus")
anchor_taxa <- c("Cartorhynchus_lenticarpus", "Sclerocormus_parviceps", "Chaohusaurus_brevifemoralis")

# the topology is the same as this is resolved in strict consensus
bindellini_outgroups <- keep.tip(bindellini_trees[[1]], tip = c(Hupehsuchia, outgroups, anchor_taxa))

outgroup_topology <-
  superTree(c(bindellini_outgroups, chen_tree), rooted = TRUE)
plot(outgroup_topology, no.margin = TRUE)

moon_supertrees <-
  moon_trees |>
    future_map(~ superTree(c(.x, sander_tree, outgroup_topology), rooted = TRUE), .progress = TRUE)
class(moon_supertrees) <- "multiPhylo"

plot(ladderize(moon_supertrees[[1]]), no.margin = TRUE, cex = 0.5)
```

```{r strap}
library(strap)

replace_name_underscore <-
  function(data) {
    # Replace spaces with underscores in the `accepted_name` column.
    #
    # Args:
    #   data: a tibble or data.frame with an `accepted_name` column.
    #
    # Returns:
    #   A tibble with the spaces in strings in the accepted_name column replaced with underscores.
    data |>
          mutate(accepted_name = str_replace_all(accepted_name, "\\s", "_"))
  }

data <- replace_name_underscore(data)

names_data <-
  data |>
  pull(accepted_name) |>
  unique()

missing_taxa_phylo <-
  function(phy, taxa) {
    # List taxa not found in a tree.
    #
    # Args:
    #   phy: a `phylo` or `multiPhylo` object containing tree topologies.
    #   taxa: a character vector of taxa to query their presence in the tree(s).
    #
    # Returns:
    #   A character vector of taxa not identified in the tree(s). Note that character transformations are not checked, so that species with a space between names will not be identified if the tree has underscores between species name parts.
    phy$tip.label[!(phy$tip.label %in% taxa)]
  }

identify_taxa_not_in_phylo <-
  function(phy, taxa) {
    # Identify taxa from a set of data that are not included in phylogenetic tree(s).
    #
    # Args:
    #   phy: a `phylo` or `multiPhylo` object containing tree topologies.
    #   taxa: a character vector of taxa to query their presence in the tree(s).
    #
    # Returns:
    #   A character vector of taxa not identified in the tree(s). Note that character transformations are not checked, so that species with a space between names will not be identified if the tree has underscores between species name parts.
    #
    #   If a `multiPhylo` object is given, then a list is returned with two items:
    #     1. A character vector of unique taxon names missing across all trees, and
    #     2. A list of taxa missing for each tree.
    if (class(phy) == "phylo") {
      missing_taxa_phylo(phy, taxa)
    } else if (class(phy) == "multiPhylo") {
      per_tree_missing <-
        phy |>
          purrr::map(~ missing_taxa_phylo(.x, taxa))
      list(
        missing_taxa = unique(unlist(per_tree_missing)),
        per_tree_missing_taxa = per_tree_missing
      )
    } else {
      stop("Tree is not a `phylo` or `muliPhylo` object.")
    }
  }

taxa_not_in_trees <- identify_taxa_not_in_phylo(phy = moon_supertrees, taxa = names_data)

reduce_trees <-
  function(phy, taxa) {
    # Reduces trees to a specified set of taxa by dropping unmatched tip using `ape::drop.tip`.
    #
    # Args:
    #   phy: a `phylo` or `mulitPhylo` object.
    #   taxa: a character vector of taxon names to remove.
    #
    # Returns:
    #   A `phylo` or `multiPhylo` object matching the input phylogenetic trees but with the specified taxa removed.
    if (class(phy) == "phylo") {
      reduced_phy <-
        phy |>
        drop.tip(taxa)
    } else if (class(phy) == "multiPhylo") {
      reduced_phy <-
        phy |>
        purrr::map(~ drop.tip(.x, taxa)) |>
        purrr::map(`class<-`, "phylo")
      class(reduced_phy) <- "multiPhylo"
    } else {
      stop("Tree is not a `phylo` or `muliPhylo` object.")
    }
    reduced_phy
  }

small_trees <-
  reduce_trees(moon_supertrees, taxa_not_in_trees[[1]])

compute_taxon_ranges <-
  function(data) {
    # Calculate the early and late range ages of a set of tax from individual occurrence data.
    #
    # Args:
    #   data: a tibble or data.frame of taxa including the column `accepted_name` on which to group taxa and the columns `max_ma` and `min_ma` indicating occurrence range ages.
    #
    # Returns:
    #   A tibble of taxon accepted names with their first and last appearance dates in `FAD` and `LAD` columns. [not yet implemented:] The uncertainty of the appearance is also indicated by returning the maximum values of `min_ma` and minimum values of `max_ma`.
    fad_lad <-
      data |>
        group_by(accepted_name) |>
        summarize(
          FAD     = max(max_ma),
          LAD     = min(min_ma),
        )
  }

fadlad_for_stratcongr <-
  data|>
    compute_taxon_ranges() |>
    mutate(accepted_name = str_replace_all(accepted_name, "\\s", "_")) |>
    replace_name_underscore() |>
    filter(accepted_name %in% moon_supertrees[[1]]$tip.label) |>
    column_to_rownames("accepted_name")

strat_cong <-
  StratPhyloCongruence(small_trees, fadlad_for_stratcongr, rlen = 2, method = "equal")

most_congruent_trees <-
  function(StratPhyloCongruence_results, metric = "SCI", cutoff = 0.6) {
    # Show most stratigraphically congruent trees from the results of StratPhyloCongruence.
    #
    # Args:
    #   StratPhyloCongruence_results: the results of a stratigraphical congruence analysis using strap::StratPhyloCongruence.
    #   metric: the column variable to filter on. Can be a congruence metric of the p-value.
    #   cutoff: the cut-off value below which to discard trees.
    #
    # Returns:
    #   A vector of numbers indicating the positions of trees from the input to StratPhyloCongruence that meet the cut off value.
    #
    #   If `metric` is one of the stratigraphical congruence metrics then the cut-off value is treated as a minimum1, returning trees with values greater than the cut-off, if a *p-value is used (e.g. `est.p.GER` or `p.Wills`) then the `cutoff` is treated as a maximum
    congruence_df <-
      StratPhyloCongruence_results$input.tree.results |>
      as.data.frame() |>
      rownames_to_column() |>
      as_tibble()
    if (str_detect(metric, "p.")) {
      filtered_df <-
        congruence_df |>
        filter(.data[[metric]] < {{ cutoff }})
    } else {
      filtered_df <-
        congruence_df |>
        filter(.data[[metric]] > {{ cutoff }})
    }
    filtered_df |>
      mutate(tree = str_replace_all(rowname, "tree_", "")) |>
      pull(tree) |>
      as.numeric()
  }

good_trees <- most_congruent_trees(strat_cong, metric = "SCI", cutoff = 0.5)
```

```{r cal3}
library(paleotree)

pt_data <-
  names_data |>
  purrr::map(~ filter(data, accepted_name == .x))
time_list <-
  occData2timeList(pt_data, intervalType = "dateRange")
dimnames(time_list[[2]])[[1]] <- str_replace(names_data, "\\s", "_")

tax_div_cal3 <-
  taxicDivDisc(time_list, plot = TRUE) |>
  as_tibble()

tax_div_cal3 |>
  mutate(midpoint = (int.start + int.end) / 2) |>
  ggplot(aes(x = midpoint, y = int.div)) +
    geom_col(width = 1) +
    scale_x_reverse() +
    labs(x = "Age (Ma)", y = "Taxic diversity")


dur_freq <- make_durationFreqDisc(time_list)
srRes <- optim(
  parInit(dur_freq),
  dur_freq,
  lower = parLower(dur_freq),
  upper = parUpper(dur_freq),
  method = "L-BFGS-B",
  control = list(maxit = 1000000)
)
sRate <- srRes[[1]][2]
divRate <- srRes[[1]][1]

surv_mod <- make_inverseSurv(time_list)
constr_fun <- constrainParPaleo(surv_mod, match.all ~ match.all)

results <-
  optim(
    parInit(constr_fun),
    constr_fun,
    lower = parLower(constr_fun),
    upper = parUpper(constr_fun),
    method = "L-BFGS-B",
    control = list(maxit = 1000000)
  )

availableCores()
plan(multisession)

ttree <-
  small_trees[good_trees] |>
  future_map(~ bin_cal3TimePaleoPhy(.x, time_list, brRate = results$par[1], extRate = results$par[2], sampRate = results$par[3], ntrees = 10, plot = TRUE, root.max = 100), .progress = TRUE) |>
    #rexp(rate = 0.17, n = 1) + 1: 39% < 252.17, 0.95 HPDI: 249.2–266.8
    #rgamma(shape - 3, scale = 0.8, n = 1) + 1: 71% < 252.2, 0.95 HPDI: 249.4–254.33
  unlist(recursive = FALSE)
class(ttree) <- "multiPhylo"

phylo_div_cal3 <-
  multiDiv(ttree, int.length = 0.1)

as_tibble(phylo_div_cal3$int.times) |>
  add_column(as_tibble(phylo_div_cal3$median.curve)) |>
  mutate(midpoint = int.start - (int.end - int.start) / 2) |>
  ggplot(aes(x = midpoint, y = median, ymin = low.95.quantile, ymax = high.95.quantile)) +
    geom_ribbon(fill = "grey60") +
    geom_line(lwd = 1) +
    scale_x_reverse() +
    labs(x = "Age (Ma)", y = "cal3 phylogenetic diversity (med, 95% CI)")
ggsave(paste0(dirs$figs, "cal3_phylogenetic_diversity.pdf"), width = 5, height = 3)

sapply(ttree, "[[", "root.time") |>
  as_tibble() |>
  ggplot(aes(x = value)) +
    geom_histogram() +
    scale_x_reverse() +
    labs(x = "Root age (Ma)", y = "Count")
ggsave(paste0(dirs$figs, "cal3_root_ages.pdf"), width = 5, height = 3)

ttree_constr <-
  small_trees[good_trees] |>
  future_map(~ bin_cal3TimePaleoPhy(.x, time_list, brRate = results$par[1], extRate = results$par[2], sampRate = results$par[3], ntrees = 10, plot = TRUE, root.max = rgamma(shape = 3, scale = 0.8, n = 1) + 1), .progress = TRUE) |>
    #rexp(rate = 0.17, n = 1) + 1: 39% < 252.17, 0.95 HPDI: 249.2–266.8
    # rgamma(shape = 3, scale = 0.8, n = 1) + 1: 71% < 252.2, 0.95 HPDI: 249.4–254.33
  unlist(recursive = FALSE)
class(ttree) <- "multiPhylo"

phylo_div_cal3_constr <-
  multiDiv(ttree_constr, int.length = 0.1)

as_tibble(phylo_div_cal3_constr$int.times) |>
  add_column(as_tibble(phylo_div_cal3_constr$median.curve)) |>
  mutate(midpoint = int.start - (int.end - int.start) / 2) |>
  ggplot(aes(x = midpoint, y = median, ymin = low.95.quantile, ymax = high.95.quantile)) +
    geom_ribbon(fill = "grey60") +
    geom_line(lwd = 1) +
    scale_x_reverse() +
    labs(x = "Age (Ma)", y = "cal3 phylogenetic diversity (med, 95% CI)")
ggsave(paste0(dirs$figs, "cal3_constr_phylogenetic_diversity.pdf"), width = 5, height = 3)
```

```{r mapping_occurrences}
library(sf)
library(lwgeom)
library(rnaturalearth)
library(rnaturalearthdata)

map_data <-
  read_tsv(paste0(dirs$data, "ichthyosaur_occurrences.tsv")) |>
  filter(complete.cases(lng, lat)) |>
  st_as_sf(coords = c("lng", "lat"), crs = 4326)

world_map <-
  ne_countries(returnclass = "sf")

ggplot() +
  geom_sf(data = world_map, inherit.aes = FALSE) +
  geom_sf(data = map_data, mapping = aes(colour = max_ma)) +
  scale_colour_viridis(name = "Age (Ma)") +
  coord_sf(crs = "+proj=wink2") +
  # theme_void() +
  theme(
    # legend.position = "none",
    panel.border = element_blank()
  )
# ggsave(paste0(dirs$figs, "occurrence_modern_map.pdf"), width = 6, height = 3)
```

